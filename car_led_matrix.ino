// A basic everyday NeoPixel strip test program.

// NEOPIXEL BEST PRACTICES for most reliable operation:
// - Add 1000 uF CAPACITOR between NeoPixel strip's + and - connections.
// - MINIMIZE WIRING LENGTH between microcontroller board and first pixel.
// - NeoPixel strip's DATA-IN should pass through a 300-500 OHM RESISTOR.
// - AVOID connecting NeoPixels on a LIVE CIRCUIT. If you must, ALWAYS
//   connect GROUND (-) first, then +, then data.
// - When using a 3.3V microcontroller with a 5V-powered NeoPixel strip,
//   a LOGIC-LEVEL CONVERTER on the data line is STRONGLY RECOMMENDED.
// (Skipping these may work OK on your workbench but can fail in the field)

#include <Adafruit_NeoPixel.h>
#ifdef __AVR__
 #include <avr/power.h> // Required for 16 MHz Adafruit Trinket
#endif

// Which pin on the Arduino is connected to the NeoPixels?
// On a Trinket or Gemma we suggest changing this to 1:
#define LED_PIN    3

// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 256

// Declare our NeoPixel strip object:
Adafruit_NeoPixel matrix(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

const char heartImage[] PROGMEM = {"\0\0\0\0\0\0""8\30%\2059Y\232Bfl.H\22\10\14\0\0\0\0\0\0\22\10\14l.H\233B"
  "g\2059Y8\30%\0\0\0\0\0\0\0\0\0#\17\30\253Iq\347c\231\356f\236\331]\220q0"
  "K\0\0\0\0\0\0q0K\331]\220\356f\236\347c\231\253Iq#\17\30\0\0\0\27\12\17\315"
  "X\210\356f\236\356f\236\356f\236\356f\236\356f\236p0Jp0J\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\315X\210\27\12\17\2028V\356f\236\356f\236\356"
  "f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356"
  "f\236\356f\236\356f\236\356f\236\2017V\305T\203\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\305T\203\330\\\217\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\330\\\217\313W\206\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\313W\206\233Bg\356f\236\356f\236\356f\236\356"
  "f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356"
  "f\236\356f\236\356f\236\233BgA\34+\356f\236\356f\236\356f\236\356f\236\356"
  "f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356"
  "f\236\356f\236@\34+\1\0\1\241Ek\356f\236\356f\236\356f\236\356f\236\356f"
  "\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\240D"
  "j\0\0\0\0\0\0\32\13\21\313W\207\356f\236\356f\236\356f\236\356f\236\356f"
  "\236\356f\236\356f\236\356f\236\356f\236\356f\236\313W\207\32\13\21\0\0\0"
  "\0\0\0\0\0\0*\22\34\325[\215\356f\236\356f\236\356f\236\356f\236\356f\236"
  "\356f\236\356f\236\356f\236\325[\215*\22\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  ")\22\33\300R\200\356f\236\356f\236\356f\236\356f\236\356f\236\356f\236\300"
  "R\200)\22\33\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\21\7\13\232Bf\356"
  "f\236\356f\236\356f\236\356f\236\232Bf\21\7\13\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M!3\314X\210\314X\210M!3\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\1a*@a*@\1"
  "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
};

const char smileImage[] PROGMEM = {"\0\0\0\0\0\0\0\0\0\0\0\0""000\226\226\226\330\330\330\372\372\372\372\372"
  "\372\330\330\330\226\226\226000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\10"
  "\10\230\230\230\374\374\374\322\322\322\202\202\202ZZZZZZ\202\202\202\322"
  "\322\322\374\374\374\230\230\230\10\10\10\0\0\0\0\0\0\0\0\0\10\10\10\300"
  "\300\300\356\356\356XXX\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0XXX\356\356\356"
  "\300\300\300\10\10\10\0\0\0\0\0\0\230\230\230\356\356\356000\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""000\356\356\356\230\230\230\0\0\0""0"
  "00\374\374\374XXX\20\20\20NNN&&&\0\0\0\0\0\0\0\0\0\0\0\0&&&NNN\20\20\20X"
  "XX\374\374\374000\226\226\226\322\322\322\20\20\20\336\336\336\374\374\374"
  "\372\372\372HHH\0\0\0\0\0\0HHH\372\372\372\374\374\374\336\336\336\20\20"
  "\20\322\322\322\226\226\226\330\330\330\202\202\202NNN\374\374\374\34\34"
  "\34\300\300\300\242\242\242\0\0\0\0\0\0\242\242\242\300\300\300\34\34\34"
  "\374\374\374NNN\202\202\202\330\330\330\372\372\372ZZZ&&&\372\372\372\300"
  "\300\300\372\372\372vvv\0\0\0\0\0\0vvv\372\372\372\300\300\300\372\372\372"
  "&&&ZZZ\372\372\372\372\372\372ZZZ\0\0\0HHH\242\242\242vvv\0\0\0\0\0\0\0\0"
  "\0\0\0\0vvv\242\242\242HHH\0\0\0ZZZ\372\372\372\330\330\330\202\202\202\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\202"
  "\202\202\330\330\330\226\226\226\322\322\322\0\0\0\34\34\34\230\230\230\20"
  "\20\20\0\0\0\0\0\0\0\0\0\0\0\0\20\20\20\242\242\242\26\26\26\0\0\0\322\322"
  "\322\226\226\226000\374\374\374XXX\34\34\34\344\344\344\322\322\322NNN\10"
  "\10\10\10\10\10NNN\330\330\330\336\336\336\20\20\20XXX\374\374\374000\0\0"
  "\0\230\230\230\356\356\356000\34\34\34\262\262\262\374\374\374\374\374\374"
  "\374\374\374\374\374\374\262\262\262\34\34\34""000\356\356\356\226\226\226"
  "\0\0\0\0\0\0\10\10\10\300\300\300\356\356\356XXX\0\0\0\34\34\34NNNNNN\34"
  "\34\34\0\0\0XXX\356\356\356\300\300\300\10\10\10\0\0\0\0\0\0\0\0\0\10\10"
  "\10\226\226\226\374\374\374\322\322\322\202\202\202ZZZZZZ\202\202\202\322"
  "\322\322\374\374\374\226\226\226\10\10\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0""000\226\226\226\330\330\330\372\372\372\372\372\372\330\330\330\226"
  "\226\226000\0\0\0\0\0\0\0\0\0\0\0\0"
};

const char sadImage[] PROGMEM = {"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0]\0\0\233\0\0\0\0\0\0\0\0\0\0\0\0\0\0\224\0\0\224"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\226\0\0\261\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\312\0\0\224\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""0\0\0""0\0\0\31\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v\0\0\262\0\0\240\0\0\300\0\0\244\0"
  "\0\244\0\0\263\0\0\306\0\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\263\0"
  "\0\273\0\0p\0\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\251\0\0\270\0\0@\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\215\0\0\277\0\0\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0p\0\0\224\0\0\0\0\0\0\0\0\0\0\0\31\0\0\263\0\0@\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\320\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
};
unsigned int pixel;
unsigned int i;
// setup() function -- runs once at startup --------------------------------

void setup() {
  matrix.begin();           // INITIALIZE NeoPixel strip object (REQUIRED)
  matrix.show();            // Turn OFF all pixels ASAP
  matrix.setBrightness(30); // Set BRIGHTNESS (max = 255)
}

// loop() function -- runs repeatedly as long as board is on ---------------

void loop() {
  displayImage(sadImage);
  delay(10000);
  displayImage(smileImage);
  delay(10000);
  displayImage(heartImage);
  delay(10000);
}

void displayImage(char img[]) {
  i = 0;
  for (int i = 0; i < matrix.numPixels(); i++) {
    pixel = indexToPixel(i);
    matrix.setPixelColor(pixel, pgm_read_byte_near(img + (i*3)), pgm_read_byte_near(img + (i*3) + 1), pgm_read_byte_near(img + (i*3) + 2));
  }
  matrix.show();
}

int indexToPixel(int i) {
  // on this led matrix, the even rows count backwards
  // so we'll map the even rows backwards
  bool odd_row = i / 16 % 2 == 1;
  int pixel = odd_row ? i : (i / 16 * 16) + 15 - (i % 16);
  return pixel;
}

